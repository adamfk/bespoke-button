// Autogenerated with StateSmith 0.11.2-alpha+4a4e30018e9a371124530fa96cf2ba3322b80459.
// Algorithm: Balanced1. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#include "BeButton2Sm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(BeButton2Sm* sm, BeButton2Sm_Func desired_state_exit_handler);

static void ROOT_enter(BeButton2Sm* sm);

static void ROOT_exit(BeButton2Sm* sm);

static void HELD_AT_START_enter(BeButton2Sm* sm);

static void HELD_AT_START_exit(BeButton2Sm* sm);

static void HELD_AT_START_do(BeButton2Sm* sm);

static void PRESSED_DEBOUNCE_enter(BeButton2Sm* sm);

static void PRESSED_DEBOUNCE_exit(BeButton2Sm* sm);

static void PRESSED_DEBOUNCE_do(BeButton2Sm* sm);

static void PRESSED_STABLE_enter(BeButton2Sm* sm);

static void PRESSED_STABLE_exit(BeButton2Sm* sm);

static void PRESSED_STABLE_do(BeButton2Sm* sm);

static void CONFIRM_LONG_enter(BeButton2Sm* sm);

static void CONFIRM_LONG_exit(BeButton2Sm* sm);

static void CONFIRM_LONG_do(BeButton2Sm* sm);

static void PRESSED_LONG_enter(BeButton2Sm* sm);

static void PRESSED_LONG_exit(BeButton2Sm* sm);

static void DELAY_1ST_REPEAT_enter(BeButton2Sm* sm);

static void DELAY_1ST_REPEAT_exit(BeButton2Sm* sm);

static void DELAY_1ST_REPEAT_do(BeButton2Sm* sm);

static void NO_REPEAT_enter(BeButton2Sm* sm);

static void NO_REPEAT_exit(BeButton2Sm* sm);

static void PRESSED_REPEAT_enter(BeButton2Sm* sm);

static void PRESSED_REPEAT_exit(BeButton2Sm* sm);

static void PRESSED_REPEAT_do(BeButton2Sm* sm);

static void RELEASED_DEBOUNCE_enter(BeButton2Sm* sm);

static void RELEASED_DEBOUNCE_exit(BeButton2Sm* sm);

static void RELEASED_DEBOUNCE_do(BeButton2Sm* sm);

static void RELEASED_STABLE_enter(BeButton2Sm* sm);

static void RELEASED_STABLE_exit(BeButton2Sm* sm);

static void RELEASED_STABLE_do(BeButton2Sm* sm);

static void RELEASED_STABLE_InitialState_transition(BeButton2Sm* sm);

static void SEQUENCE_enter(BeButton2Sm* sm);

static void SEQUENCE_exit(BeButton2Sm* sm);

static void SEQUENCE_do(BeButton2Sm* sm);

static void SEQUENCE_END_enter(BeButton2Sm* sm);

static void SEQUENCE_END_exit(BeButton2Sm* sm);

static void STARTUP_DELAY_enter(BeButton2Sm* sm);

static void STARTUP_DELAY_exit(BeButton2Sm* sm);

static void STARTUP_DELAY_do(BeButton2Sm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void BeButton2Sm_ctor(BeButton2Sm* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void BeButton2Sm_start(BeButton2Sm* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(STARTUP_DELAY)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `STARTUP_DELAY`.
            STARTUP_DELAY_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = BeButton2Sm_StateId_STARTUP_DELAY;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
void BeButton2Sm_dispatch_event(BeButton2Sm* sm, BeButton2Sm_EventId event_id)
{
    BeButton2Sm_Func behavior_func = sm->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        sm->ancestor_event_handler = NULL;
        behavior_func(sm);
        behavior_func = sm->ancestor_event_handler;
    }
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(BeButton2Sm* sm, BeButton2Sm_Func desired_state_exit_handler)
{
    while (sm->current_state_exit_handler != desired_state_exit_handler)
    {
        sm->current_state_exit_handler(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(BeButton2Sm* sm)
{
    // State machine root is a special case. It cannot be exited. Mark as unused.
    (void)sm;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HELD_AT_START
////////////////////////////////////////////////////////////////////////////////

static void HELD_AT_START_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = HELD_AT_START_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = HELD_AT_START_do;
    
    // HELD_AT_START behavior
    // uml: enter / { output_press = true; }
    {
        // Step 1: execute action `output_press = true;`
        sm->vars.output_press = true;
    } // end of behavior for HELD_AT_START
}

static void HELD_AT_START_exit(BeButton2Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void HELD_AT_START_do(BeButton2Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // HELD_AT_START behavior
    // uml: 1. do / { t2_ms = 0; }
    {
        // Step 1: execute action `t2_ms = 0;`
        sm->vars.t2_ms = 0;
        
        // Step 2: determine if ancestor gets to handle event next.
        // Don't consume special `do` event.
    } // end of behavior for HELD_AT_START
    
    // HELD_AT_START behavior
    // uml: do [! input_active] TransitionTo(RELEASED_DEBOUNCE)
    if (! sm->vars.input_active)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        HELD_AT_START_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RELEASED_DEBOUNCE`.
        RELEASED_DEBOUNCE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = BeButton2Sm_StateId_RELEASED_DEBOUNCE;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for HELD_AT_START
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PRESSED_DEBOUNCE
////////////////////////////////////////////////////////////////////////////////

static void PRESSED_DEBOUNCE_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = PRESSED_DEBOUNCE_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = PRESSED_DEBOUNCE_do;
    
    // PRESSED_DEBOUNCE behavior
    // uml: enter / { press_count++; }
    {
        // Step 1: execute action `press_count++;`
        sm->vars.press_count++;
    } // end of behavior for PRESSED_DEBOUNCE
    
    // PRESSED_DEBOUNCE behavior
    // uml: enter / { output_press_event = true; }
    {
        // Step 1: execute action `output_press_event = true;`
        sm->vars.output_press_event = true;
    } // end of behavior for PRESSED_DEBOUNCE
    
    // PRESSED_DEBOUNCE behavior
    // uml: enter / { output_press = true; }
    {
        // Step 1: execute action `output_press = true;`
        sm->vars.output_press = true;
    } // end of behavior for PRESSED_DEBOUNCE
}

static void PRESSED_DEBOUNCE_exit(BeButton2Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void PRESSED_DEBOUNCE_do(BeButton2Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // PRESSED_DEBOUNCE behavior
    // uml: do [t1_ms > 50] TransitionTo(PRESSED_STABLE)
    if (sm->vars.t1_ms > 50)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        PRESSED_DEBOUNCE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PRESSED_STABLE`.
        PRESSED_STABLE_enter(sm);
        
        // PRESSED_STABLE.<InitialState> behavior
        // uml: TransitionTo(CONFIRM_LONG)
        {
            // Step 1: Exit states until we reach `PRESSED_STABLE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `CONFIRM_LONG`.
            CONFIRM_LONG_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = BeButton2Sm_StateId_CONFIRM_LONG;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for PRESSED_STABLE.<InitialState>
    } // end of behavior for PRESSED_DEBOUNCE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PRESSED_STABLE
////////////////////////////////////////////////////////////////////////////////

static void PRESSED_STABLE_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = PRESSED_STABLE_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = PRESSED_STABLE_do;
}

static void PRESSED_STABLE_exit(BeButton2Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void PRESSED_STABLE_do(BeButton2Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // PRESSED_STABLE behavior
    // uml: do [! input_active] TransitionTo(RELEASED_DEBOUNCE)
    if (! sm->vars.input_active)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RELEASED_DEBOUNCE`.
        RELEASED_DEBOUNCE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = BeButton2Sm_StateId_RELEASED_DEBOUNCE;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for PRESSED_STABLE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CONFIRM_LONG
////////////////////////////////////////////////////////////////////////////////

static void CONFIRM_LONG_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = CONFIRM_LONG_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = CONFIRM_LONG_do;
}

static void CONFIRM_LONG_exit(BeButton2Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = PRESSED_STABLE_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = PRESSED_STABLE_do;  // the next ancestor that handles this event is PRESSED_STABLE
}

static void CONFIRM_LONG_do(BeButton2Sm* sm)
{
    // Setup handler for next ancestor that listens to `do` event.
    sm->ancestor_event_handler = PRESSED_STABLE_do;
    
    // CONFIRM_LONG behavior
    // uml: do [t1_ms > 500] TransitionTo(PRESSED_LONG)
    if (sm->vars.t1_ms > 500)
    {
        // Step 1: Exit states until we reach `PRESSED_STABLE` state (Least Common Ancestor for transition).
        CONFIRM_LONG_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PRESSED_LONG`.
        PRESSED_LONG_enter(sm);
        
        // PRESSED_LONG.<InitialState> behavior
        // uml: [disable_repeat] TransitionTo(NO_REPEAT)
        if (sm->vars.disable_repeat)
        {
            // Step 1: Exit states until we reach `PRESSED_LONG` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `NO_REPEAT`.
            NO_REPEAT_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = BeButton2Sm_StateId_NO_REPEAT;
            sm->ancestor_event_handler = NULL;
            return;
        } // end of behavior for PRESSED_LONG.<InitialState>
        
        // PRESSED_LONG.<InitialState> behavior
        // uml: else TransitionTo(DELAY_1ST_REPEAT)
        {
            // Step 1: Exit states until we reach `PRESSED_LONG` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `DELAY_1ST_REPEAT`.
            DELAY_1ST_REPEAT_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = BeButton2Sm_StateId_DELAY_1ST_REPEAT;
            sm->ancestor_event_handler = NULL;
            return;
        } // end of behavior for PRESSED_LONG.<InitialState>
    } // end of behavior for CONFIRM_LONG
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PRESSED_LONG
////////////////////////////////////////////////////////////////////////////////

static void PRESSED_LONG_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = PRESSED_LONG_exit;
    
    // PRESSED_LONG behavior
    // uml: enter / { output_long_event = true; }
    {
        // Step 1: execute action `output_long_event = true;`
        sm->vars.output_long_event = true;
    } // end of behavior for PRESSED_LONG
}

static void PRESSED_LONG_exit(BeButton2Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = PRESSED_STABLE_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state DELAY_1ST_REPEAT
////////////////////////////////////////////////////////////////////////////////

static void DELAY_1ST_REPEAT_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = DELAY_1ST_REPEAT_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = DELAY_1ST_REPEAT_do;
    
    // DELAY_1ST_REPEAT behavior
    // uml: enter / { t2_ms = 0; }
    {
        // Step 1: execute action `t2_ms = 0;`
        sm->vars.t2_ms = 0;
    } // end of behavior for DELAY_1ST_REPEAT
}

static void DELAY_1ST_REPEAT_exit(BeButton2Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = PRESSED_LONG_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = PRESSED_STABLE_do;  // the next ancestor that handles this event is PRESSED_STABLE
}

static void DELAY_1ST_REPEAT_do(BeButton2Sm* sm)
{
    // Setup handler for next ancestor that listens to `do` event.
    sm->ancestor_event_handler = PRESSED_STABLE_do;
    
    // DELAY_1ST_REPEAT behavior
    // uml: do [t2_ms > 350] TransitionTo(PRESSED_REPEAT)
    if (sm->vars.t2_ms > 350)
    {
        // Step 1: Exit states until we reach `PRESSED_LONG` state (Least Common Ancestor for transition).
        DELAY_1ST_REPEAT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PRESSED_REPEAT`.
        PRESSED_REPEAT_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = BeButton2Sm_StateId_PRESSED_REPEAT;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for DELAY_1ST_REPEAT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state NO_REPEAT
////////////////////////////////////////////////////////////////////////////////

static void NO_REPEAT_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = NO_REPEAT_exit;
}

static void NO_REPEAT_exit(BeButton2Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = PRESSED_LONG_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PRESSED_REPEAT
////////////////////////////////////////////////////////////////////////////////

static void PRESSED_REPEAT_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = PRESSED_REPEAT_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = PRESSED_REPEAT_do;
    
    // PRESSED_REPEAT behavior
    // uml: enter / { t2_ms = 0; }
    {
        // Step 1: execute action `t2_ms = 0;`
        sm->vars.t2_ms = 0;
    } // end of behavior for PRESSED_REPEAT
    
    // PRESSED_REPEAT behavior
    // uml: enter / { output_repeat_event = true; }
    {
        // Step 1: execute action `output_repeat_event = true;`
        sm->vars.output_repeat_event = true;
    } // end of behavior for PRESSED_REPEAT
}

static void PRESSED_REPEAT_exit(BeButton2Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = PRESSED_LONG_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = PRESSED_STABLE_do;  // the next ancestor that handles this event is PRESSED_STABLE
}

static void PRESSED_REPEAT_do(BeButton2Sm* sm)
{
    // Setup handler for next ancestor that listens to `do` event.
    sm->ancestor_event_handler = PRESSED_STABLE_do;
    
    // PRESSED_REPEAT behavior
    // uml: 1. do [disable_repeat] TransitionTo(NO_REPEAT)
    if (sm->vars.disable_repeat)
    {
        // Step 1: Exit states until we reach `PRESSED_LONG` state (Least Common Ancestor for transition).
        PRESSED_REPEAT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `NO_REPEAT`.
        NO_REPEAT_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = BeButton2Sm_StateId_NO_REPEAT;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for PRESSED_REPEAT
    
    // PRESSED_REPEAT behavior
    // uml: do [t2_ms > REPEAT_INTERVAL_MS] TransitionTo(PRESSED_REPEAT)
    if (sm->vars.t2_ms > REPEAT_INTERVAL_MS)
    {
        // Step 1: Exit states until we reach `PRESSED_LONG` state (Least Common Ancestor for transition).
        PRESSED_REPEAT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PRESSED_REPEAT`.
        PRESSED_REPEAT_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = BeButton2Sm_StateId_PRESSED_REPEAT;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for PRESSED_REPEAT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RELEASED_DEBOUNCE
////////////////////////////////////////////////////////////////////////////////

static void RELEASED_DEBOUNCE_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = RELEASED_DEBOUNCE_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = RELEASED_DEBOUNCE_do;
    
    // RELEASED_DEBOUNCE behavior
    // uml: enter / { output_release_event = true; }
    {
        // Step 1: execute action `output_release_event = true;`
        sm->vars.output_release_event = true;
    } // end of behavior for RELEASED_DEBOUNCE
    
    // RELEASED_DEBOUNCE behavior
    // uml: enter / { output_press = false; }
    {
        // Step 1: execute action `output_press = false;`
        sm->vars.output_press = false;
    } // end of behavior for RELEASED_DEBOUNCE
}

static void RELEASED_DEBOUNCE_exit(BeButton2Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void RELEASED_DEBOUNCE_do(BeButton2Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // RELEASED_DEBOUNCE behavior
    // uml: do [t2_ms > 50] TransitionTo(RELEASED_STABLE)
    if (sm->vars.t2_ms > 50)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        RELEASED_DEBOUNCE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RELEASED_STABLE`.
        RELEASED_STABLE_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        RELEASED_STABLE_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for RELEASED_DEBOUNCE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RELEASED_STABLE
////////////////////////////////////////////////////////////////////////////////

static void RELEASED_STABLE_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = RELEASED_STABLE_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = RELEASED_STABLE_do;
}

static void RELEASED_STABLE_exit(BeButton2Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void RELEASED_STABLE_do(BeButton2Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // RELEASED_STABLE behavior
    // uml: do [input_active] TransitionTo(PRESSED_DEBOUNCE)
    if (sm->vars.input_active)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PRESSED_DEBOUNCE`.
        PRESSED_DEBOUNCE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = BeButton2Sm_StateId_PRESSED_DEBOUNCE;
        // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
        return;
    } // end of behavior for RELEASED_STABLE
}

static void RELEASED_STABLE_InitialState_transition(BeButton2Sm* sm)
{
    // RELEASED_STABLE.<InitialState> behavior
    // uml: TransitionTo(SEQUENCE)
    {
        // Step 1: Exit states until we reach `RELEASED_STABLE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SEQUENCE`.
        SEQUENCE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = BeButton2Sm_StateId_SEQUENCE;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for RELEASED_STABLE.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SEQUENCE
////////////////////////////////////////////////////////////////////////////////

static void SEQUENCE_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = SEQUENCE_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = SEQUENCE_do;
}

static void SEQUENCE_exit(BeButton2Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = RELEASED_STABLE_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = RELEASED_STABLE_do;  // the next ancestor that handles this event is RELEASED_STABLE
}

static void SEQUENCE_do(BeButton2Sm* sm)
{
    // Setup handler for next ancestor that listens to `do` event.
    sm->ancestor_event_handler = RELEASED_STABLE_do;
    
    // SEQUENCE behavior
    // uml: do [t2_ms > 500] TransitionTo(SEQUENCE_END)
    if (sm->vars.t2_ms > 500)
    {
        // Step 1: Exit states until we reach `RELEASED_STABLE` state (Least Common Ancestor for transition).
        SEQUENCE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SEQUENCE_END`.
        SEQUENCE_END_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = BeButton2Sm_StateId_SEQUENCE_END;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for SEQUENCE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SEQUENCE_END
////////////////////////////////////////////////////////////////////////////////

static void SEQUENCE_END_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = SEQUENCE_END_exit;
    
    // SEQUENCE_END behavior
    // uml: enter [press_count > 0] / { output_seq_end_event = true; }
    if (sm->vars.press_count > 0)
    {
        // Step 1: execute action `output_seq_end_event = true;`
        sm->vars.output_seq_end_event = true;
    } // end of behavior for SEQUENCE_END
}

static void SEQUENCE_END_exit(BeButton2Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = RELEASED_STABLE_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STARTUP_DELAY
////////////////////////////////////////////////////////////////////////////////

static void STARTUP_DELAY_enter(BeButton2Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = STARTUP_DELAY_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = STARTUP_DELAY_do;
}

static void STARTUP_DELAY_exit(BeButton2Sm* sm)
{
    // adjust function pointers for this state's exit
    sm->current_state_exit_handler = ROOT_exit;
    sm->current_event_handlers[BeButton2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void STARTUP_DELAY_do(BeButton2Sm* sm)
{
    // No ancestor state handles `do` event.
    
    // STARTUP_DELAY behavior
    // uml: do [t2_ms > 25] TransitionTo(ROOT.<ChoicePoint>(INIT_CHOICE))
    if (sm->vars.t2_ms > 25)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        STARTUP_DELAY_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>(INIT_CHOICE)`.
        // ROOT.<ChoicePoint>(INIT_CHOICE) is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<ChoicePoint>(INIT_CHOICE) behavior
        // uml: [input_active] TransitionTo(HELD_AT_START)
        if (sm->vars.input_active)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `HELD_AT_START`.
            HELD_AT_START_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            sm->state_id = BeButton2Sm_StateId_HELD_AT_START;
            // No ancestor handles event. Can skip nulling `ancestor_event_handler`.
            return;
        } // end of behavior for ROOT.<ChoicePoint>(INIT_CHOICE)
        
        // ROOT.<ChoicePoint>(INIT_CHOICE) behavior
        // uml: else TransitionTo(RELEASED_STABLE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `RELEASED_STABLE`.
            RELEASED_STABLE_enter(sm);
            
            // Finish transition by calling pseudo state transition function.
            RELEASED_STABLE_InitialState_transition(sm);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ROOT.<ChoicePoint>(INIT_CHOICE)
    } // end of behavior for STARTUP_DELAY
}

// Thread safe.
char const * BeButton2Sm_state_id_to_string(BeButton2Sm_StateId id)
{
    switch (id)
    {
        case BeButton2Sm_StateId_ROOT: return "ROOT";
        case BeButton2Sm_StateId_HELD_AT_START: return "HELD_AT_START";
        case BeButton2Sm_StateId_PRESSED_DEBOUNCE: return "PRESSED_DEBOUNCE";
        case BeButton2Sm_StateId_PRESSED_STABLE: return "PRESSED_STABLE";
        case BeButton2Sm_StateId_CONFIRM_LONG: return "CONFIRM_LONG";
        case BeButton2Sm_StateId_PRESSED_LONG: return "PRESSED_LONG";
        case BeButton2Sm_StateId_DELAY_1ST_REPEAT: return "DELAY_1ST_REPEAT";
        case BeButton2Sm_StateId_NO_REPEAT: return "NO_REPEAT";
        case BeButton2Sm_StateId_PRESSED_REPEAT: return "PRESSED_REPEAT";
        case BeButton2Sm_StateId_RELEASED_DEBOUNCE: return "RELEASED_DEBOUNCE";
        case BeButton2Sm_StateId_RELEASED_STABLE: return "RELEASED_STABLE";
        case BeButton2Sm_StateId_SEQUENCE: return "SEQUENCE";
        case BeButton2Sm_StateId_SEQUENCE_END: return "SEQUENCE_END";
        case BeButton2Sm_StateId_STARTUP_DELAY: return "STARTUP_DELAY";
        default: return "?";
    }
}

// Thread safe.
char const * BeButton2Sm_event_id_to_string(BeButton2Sm_EventId id)
{
    switch (id)
    {
        case BeButton2Sm_EventId_DO: return "DO";
        default: return "?";
    }
}
