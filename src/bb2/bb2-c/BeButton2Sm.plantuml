@startuml BeButton2Sm

' /////////////////////////// Styles ////////////////////////////////
' Define some colors for the states. Totally optional.
skinparam state {
    ' pressed style:
    BackgroundColor<<press_style>> #c7f1ff
}

' //////////////////////// STATE ORGANIZATION ///////////////////////
' Note: StateSmith treats state names and events as case insensitive.
' More info: https://github.com/StateSmith/StateSmith/wiki/PlantUML

state INIT
state INIT_CHOICE<<choice>>

state HELD_AT_START {
    note "Inspect state ID to detect this" as N1
}

state RELEASED_DEBOUNCE {
    note "Event will clear T2 in post.\nThis allows checking press duty cycle\nif repeat is disabled." as N1
}
state RELEASED_STABLE {
    state SEQUENCE
    state SEQUENCE_END  {
        note "This is the end of a press sequence\nlike a double/triple/... click.\nEvent will clear `press_count` in post.\nThis allows checking value before clear." as N1
    }
    [*] -> SEQUENCE
}

state PRESSED_DEBOUNCE <<press_style>> {
    note "Event will clear T1 in post.\nThis allows checking press duty cycle\nif repeat is disabled." as N1
}
state PRESSED_STABLE <<press_style>> {
    [*] -> CONFIRM_LONG
    state CONFIRM_LONG
    state PRESSED_LONG {
        state NO_REPEAT
        state DELAY_1ST_REPEAT
        state PRESSED_REPEAT {
            note "Shares T2 with released states.\nCould have its own timer." as N1
        }
        [*] --> DELAY_1ST_REPEAT: else
        [*] --> NO_REPEAT: [disable_repeat]
    }
}


[*] -> INIT



' ///////////////////////// STATE HANDLERS /////////////////////////
' Syntax: https://github.com/StateSmith/StateSmith/wiki/Behaviors

INIT: enter / t2_ms = 0;
INIT -down-> INIT_CHOICE: [t2_ms > 25]

INIT_CHOICE -left-> HELD_AT_START: [input_active]
INIT_CHOICE --> RELEASED_STABLE: else

HELD_AT_START: enter / output_press = true;
HELD_AT_START --> RELEASED_DEBOUNCE: [! input_active] / t2_ms = 0;

' Wait for debounce time and then go to stable state.
RELEASED_DEBOUNCE: enter / output_release_event = true;
RELEASED_DEBOUNCE: enter / output_press = false;
RELEASED_DEBOUNCE -right-> RELEASED_STABLE: [t2_ms > 50]

' Button is released. Wait for button press.
RELEASED_STABLE -down-> PRESSED_DEBOUNCE: [input_active]

SEQUENCE --> SEQUENCE_END: [t2_ms > 500]

SEQUENCE_END: enter [press_count > 0] / output_seq_end_event = true;


' Wait for debounce time and then go to stable state.
PRESSED_DEBOUNCE: enter / press_count++;
PRESSED_DEBOUNCE: enter / output_press_event = true;
PRESSED_DEBOUNCE: enter / output_press = true;
PRESSED_DEBOUNCE -left-> PRESSED_STABLE: [t1_ms > 50]

' Button is pressed. Wait for button release.
PRESSED_STABLE -up-> RELEASED_DEBOUNCE: [! input_active]

' Button is still pressed. Wait for long press time.
CONFIRM_LONG --> PRESSED_LONG: [t1_ms > 500]

' Button has been pressed for a long time.
' Transition to repeat state if button remains pressed long enough.
PRESSED_LONG: enter / output_long_event = true;

DELAY_1ST_REPEAT: enter / t2_ms = 0;
DELAY_1ST_REPEAT --> PRESSED_REPEAT: [t2_ms > 350]

' Keep setting the button repeat event every 250 ms.
PRESSED_REPEAT: enter / t2_ms = 0;
PRESSED_REPEAT: enter / output_repeat_event = true;
PRESSED_REPEAT --> PRESSED_REPEAT: [t2_ms > 250]
PRESSED_REPEAT -up-> NO_REPEAT: 1. [disable_repeat]


' //////////////////////// StateSmith config ////////////////////////
' The below special comment block sets the StateSmith configuration.
' More info: https://github.com/StateSmith/StateSmith/issues/335

/'! $CONFIG : toml
SmRunnerSettings.transpilerId = "C99"

RenderConfig.C.HFileIncludes = """
    #include <stdint.h> // for fixed width integer state machine variables below
    """
RenderConfig.AutoExpandedVars = """
    //////////////////////////////////////////
    // INPUTS
    //////////////////////////////////////////

    // you need to add your loop time to this variable in your main loop.
    // max time is 65535 ms.
    uint16_t t1_ms;

    // you need to add your loop time to this variable in your main loop.
    // max time is 65535 ms.
    uint16_t t2_ms;

    // set to 1 when button is detected as active.
    uint8_t input_active: 1;

    // set to 1 to disable repeat events.
    // the repeat state uses t2
    uint8_t disable_repeat: 1;

    //////////////////////////////////////////
    // OUTPUTS
    //////////////////////////////////////////

    // read and clear event flags in your main loop.
    uint8_t output_release_event: 1;
    uint8_t output_press_event: 1;
    uint8_t output_long_event: 1;
    uint8_t output_repeat_event: 1;
    uint8_t output_seq_end_event: 1;

    // read these flags in your main loop, but don't clear them.
    // they are cleared automatically.
    uint8_t output_press: 1;

    uint8_t press_count;

    """

# Uncomment the below line to potentially save a byte or two of RAM per state machine
# by telling GCC to use the smallest enumeration integer type possible.
RenderConfig.C.CEnumDeclarer = "typedef enum __attribute__((packed)) {enumName}"
'/
@enduml
